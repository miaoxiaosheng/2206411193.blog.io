<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习之多线程（一）]]></title>
    <url>%2F2018%2F07%2F24%2F4%2F</url>
    <content type="text"><![CDATA[1.注意事项：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。2.Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。实现Runnable接口比继承Thread类所具有的优势：1）：适合多个相同的程序代码的线程去处理同一个资源。2）：可以避免java中的单继承的限制。3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类。提醒：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。3.线程的调度1.调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：static int MAX_PRIORITY线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY**分配给线程的默认优先级，取值为5。Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。~~ 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。~~4.常用函数说明：为什么要用join()方法?在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。为什么要用yield()方法？Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。sleep()和yield()的区别：sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。 实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。sleep 方法允许较低优先级的线程获得运行机会，但 yield()方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。**interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！** **Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用**，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。 Thread.sleep() 与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《java编程思想》笔记（一）]]></title>
    <url>%2F2018%2F07%2F24%2F3%2F</url>
    <content type="text"><![CDATA[《java编程思想》这本书被视为java经典，从这篇博客起我将总结一些重点知识：1.java多态性理解所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。Java中除了static方法和final方法（private方法本质上属于final方法，因为不能被子类访问）之外，其它所有的方法都是动态绑定，这意味着通常情况下，我们不必判定是否应该进行动态绑定—它会自动发生。final方法会使编译器生成更有效的代码，这也是为什么说声明为final方法能在一定程度上提高性能（效果不明显）。如果某个方法是静态的，它的行为就不具有多态性：（即子类不能将父类的静态方法重写）12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; StaticSuper sup = new StaticSub(); System.out.println(sup.staticGet()); System.out.println(sup.dynamicGet()); &#125;&#125;class StaticSuper&#123; public static String staticGet()&#123; //静态方法 return "BasestaticGet()"; &#125; public String dynamicGet()&#123; //未定义，动态方法 return "Base dynamicGet()"; &#125;&#125;class StaticSub extends StaticSuper &#123; public static String staticGet() &#123; //无效的重写 return "Derived staticGet()"; &#125; public String dynamicGet() &#123; return "Derived dynamicGet()"; &#125;&#125;输出结果：BasestaticGet() Derived dynamicGet()构造函数不具有多态性，他们实际上是static方法，只不过static声明是隐式的。因此构造函数也不能被override在父类构造函数内部调用具有多态行为的函数将导致无法预测的结果，因为此时子类对象还没初始化，此时调用子类方法不会得到我们想要的结果。1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125;class Glyph &#123; void draw() &#123; System.out.println("Glyph.draw()"); &#125; Glyph() &#123; System.out.println("Glyph() before draw()"); //1.先执行父类的构造方法 draw(); //在父类构造函数内部调用具有多态行为的函数 //2.执行override之后的方法 System.out.println("Glyph() after draw()"); //3.按顺序执行&#125;&#125; class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; System.out.println("RoundGlyph.RoundGlyph(). radius = " + radius); //4.最后执行子类的构造方法 &#125; void draw() &#123; System.out.println("RoundGlyph.draw(). radius = " + radius); &#125;&#125;结果：Glyph() before draw()RoundGlyph.draw(). radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(). radius = 5##讲真的这个结果足够出人意料，想知道形成这个结果的原因，首先得明确构造函数的调用顺序：（1）在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制0；（2）调用（父类）基类构造函数。从根开始递归下去，因为多态性此时调用子类覆盖后的draw()方法（要在调用RoundGlyph构造函数之前调用），由于步骤1的缘故，我们此时会发现radius的值为0；（3）按声明顺序调用成员的初始化方法；（4）最后调用子类的构造函数。显而易见，如果在父类的构造函数函数中调用多态的方法，创建子类对象时会先从父类构造方法开始执行，并且执行的是重写过后的方法。只有非private方法才可以被覆盖（override），但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行，即覆盖private方法对子类来说是一个新的方法而非重载方法。因此，在子类中，新方法名最好不要与基类的private方法采取同一名字（虽然没关系，但容易误解，以为能够覆盖基类的private方法）。Java类中属性域的访问操作都由编译器解析，因此不是多态的。父类和子类的同名属性都会分配不同的存储空间.如果子类要使用父类中的属性，须super.+属性]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多态</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next+github搭建个人博客]]></title>
    <url>%2F2018%2F01%2F09%2F1%2F</url>
    <content type="text"><![CDATA[转载请注明作者和出处：www.qiuzhibin.com建站指南1.起因小时候最喜欢将自己的心意写在小纸条上，小心翼翼的叠几层，偷偷地放在这个世界上只有自己知道的地方。 大一点有了自己的电子设备，里面有个博客，令人讨喜的是可以加密，于是写了又写，改了又改，成了自己的秘密小仓库，到后来自己忘掉了密码，秘密便成了只有天才知道的秘密。 学了计算机，看到大神们的个人博客，喜欢得不得了，碍于对技术懵懵懂懂，一直没能下手去搭建自己的博客。 期末考试结束，无聊的很，便准备着手这样长期以来没有时间拾起的小梦想。 书写此文的目的有三： 一是为了纪念一下我的个人博客初步建成。（仍需完善） 二是练习使用一下我的博客系统，记录建站心得。 三是希望帮助有缘的朋友在搭建个人博客路上快速前进。 #2.软件环境1. mac OS 10.13.5 (其他亦可) 我的电脑型号 戴尔7559 i5 装的黑苹果，我只讲述在mac平台的建站方法，windows类同。 2. git 3. brew(mac建议安装) 4. item2(对一个工具党来说，别告诉我你还在用Terminal,至于为什么，自己百度) 5. chrome（无论在哪个平台上，Chrome超好用，插件最多，没有之一，可以使用梯子插件，翻译插件） #3.需要准备什么1.服务器（存放网站的地）2.域名（搜索框里进入你博客的地址）Godaddy了解一下3.二者都没有？ 一台电脑就够了#4.历程作为一个网络小白，对于搭建博客难免一头雾水。当然了，这个世界上没有解决不了的困难，尤其是对我这种准程序员兄弟。百度与谷歌永远是常伴身边的好兄弟。（翻墙须梯子，ssr,自由门，小火箭之类的都可以）一般来讲搭建博客都会需要购买服务器，但是很多服务商给你提供了免费的服务器空间（coding,github….）,既然免费，不用白不用。首先要明白两个概念，什么叫静态网站，什么叫动态网站。具体自己百度。我只提出我自己的观点，静态网站就是一堆静态网页比如css,js,html了动态网站可以及时更新，有较复杂的后台逻辑。说白了就是静态以前端设计为主，网页不能即时更新，动态则可以。由于博客系统较为简单，一般以静态网站为主。我这里用的是github pages懒得写了因为在我之前有大牛写的比我好的多，直接上链，请按顺序阅读，建立完整体系。https://blog.csdn.net/u011475210/article/details/79023429 我的个人博 客之旅从jekyll到hexohttps://www.jianshu.com/p/05289a4bc8b2 如何搭建一个独立博客——简明 Github Pages与Hexo教程http://shenzekun.cn/hexo的next主题个性化配置教程.html next主题优化5.历程好奇---&gt; 一脸蒙蔽B---&gt; github Pages（看官方文档，注意项目名的设置）---&gt; 域名怎么解析（推荐dsnpod，用过阿里的，内容太繁琐）---&gt; 框架太麻烦，做出来不好看？（看看大佬们怎么做的）---&gt; hexo是啥？（一个静态网站框架，百度看官方文档）---&gt; 还有个Next?（Next是hexo的一个主题）---&gt; 怎么在hexo里用Next（theme文件夹下，站点配置文件配置主题，改为next）---&gt; 怎么自定义Next（结合第三个链接+next官方文档）---&gt; 太美了(我还可以加一些自己的风格，小插件)---&gt; 这么容易啊（虽然代码不懂，自己动手很geek）---&gt; 开始用 （hexo clean ,hexo g , hexo s , hexo d） 软件的话建议MWeb(专业MarkDown) 6.捷径如果实在是搭建不了，进我的github直接fork好吧，网址在网站的右上角。 hexo有个坑，hexo d 后可能404，建立CNAME文件，内容是域名即可。]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java+shell搭建博客推送]]></title>
    <url>%2F2018%2F01%2F09%2F2%2F</url>
    <content type="text"><![CDATA[前言花了大概4天的时间将博客基本搭建完，在对网站进行gulp压缩后，效率明显提升，美中不足的是博客的推送更新实在是太麻烦。懒人自有懒人的方法。突然想起了以前学过的java swing知识，心想能不能搭建起一个全自动化的图形界面呢？一个字，干！因为博客推送需要涉及一些shell命令，我将shell复杂连续的一部分放在文件里，简单的直接java执行，通过两个函数加上swingGUI界面搭成了如图所示的软件，软件由shell驱动。具体流程如下：shell中编译运行javajava swing中设置监听调用shell命令或执行shell文件swing 获取返回值或者不获取亦可注意：1.java每一次调用shell命令时，都要在线程中执行，防止影响主线程绘制界面。2.如果端口被占用可以添加.sh文件以kill+PID3.设立localhost网址，因为我目前没有方法终止部署过程所在的线程，Ctrl+C 后会将全局退出。4.java窗口与shell命令窗口，必须同时存在。，大佬可以考虑隐藏复杂的shell窗口。上代码：为了图省事，我把java代码放在一个文件里。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import java.io.*;import java.lang.reflect.Method;import java.util.logging.Level;import java.util.logging.Logger;public class Main &#123; static JMenuBar jmb; static JMenu jm; static JScrollPane js; static JFrame frame; static String sss = "程序就绪！运行期间不要关闭命令窗口！程序下方可执行简单的shell指令，本程序版权归邱智斌个人所有！"; static JButton bt1,bt2,bt3,bt4,bt5,bt6,bt7; static JMenuItem ji1; static JPanel jp1,jp2,jp3; static ProcessBuilder pb; static JTextArea text; static JTextField jtf; public static void main(String[] args)&#123; Main main = new Main(); &#125; Main()&#123; initFrame(); frame.setSize(new Dimension(520,350)); frame.setLocation(300,200); frame.setResizable(false); frame.getContentPane().setLayout(new BorderLayout()); frame.getContentPane().add(jmb,BorderLayout.NORTH); frame.getContentPane().add(jp3,BorderLayout.CENTER); frame.getContentPane().add(jp2,BorderLayout.SOUTH); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //设置窗体关闭的同时关闭jvm &#125; public static void initFrame()&#123; frame = new JFrame("hexo博客推送"); jtf = new JTextField(); jtf.setText("cd /Users/qiuzhibin/blogs/"); jmb = new JMenuBar(); text = new JTextArea(sss); js=new JScrollPane(text); js.setHorizontalScrollBarPolicy( JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); js.setVerticalScrollBarPolicy( JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); text.setLineWrap(true); text.setWrapStyleWord(true); text.setLineWrap(true); text.setWrapStyleWord(true); text.setSize(new Dimension(400,400)); text.setEditable(false); jmb.setSize(new Dimension(350,20)); jm = new JMenu("高级"); bt1 = new JButton("查看博客"); bt2 = new JButton("调试博客"); bt3 = new JButton("更新博客"); bt4 = new JButton("浏览器查看"); bt5 = new JButton("localhost"); bt6 = new JButton("执行"); bt7 = new JButton("根目录"); ji1 = new JMenuItem("解除端口(kill PID)"); ji1.addActionListener(new Listener()); JButton[] bts = &#123;bt1,bt2,bt3,bt4,bt5,bt6,bt7&#125;; for(int i=0;i&lt;bts.length;i++)&#123; bts[i].addActionListener(new Listener()); bts[i].setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR)); &#125; jp1 = new JPanel(); jp2 = new JPanel(); jp3 = new JPanel(); jp3.setLayout(new BorderLayout()); //文字加jp1 jp2.setLayout(new BorderLayout()); //最下面 jp1.setLayout(new FlowLayout()); //按钮 jp1.add(bt1); jp1.add(bt2); jp1.add(bt3); jp1.add(bt4); jp1.add(bt5); jp1.add(bt7); jp2.add(jtf,BorderLayout.CENTER); jp2.add(bt6,BorderLayout.EAST); jp3.add(jp1); jp3.add(js,BorderLayout.EAST); jmb.add(jm); jm.add(ji1); &#125; //更新博客 static void updateblogs()&#123; pb = new ProcessBuilder("/users/qiuzhibin/desktop/Myblogs/" + "update.sh"); pb.directory(new File("/users/qiuzhibin/desktop/Myblogs/")); useShell(); &#125; //调试博客 static void tiaoshi()&#123; pb = new ProcessBuilder("/users/qiuzhibin/desktop/Myblogs/" + "tiaoshi.sh"); pb.directory(new File("/users/qiuzhibin/desktop/Myblogs/")); useShell(); &#125; //打开博客目录 static void seeWenjian()&#123; pb = new ProcessBuilder("/users/qiuzhibin/desktop/Myblogs/" + "seewenjian.sh"); pb.directory(new File("/users/qiuzhibin/desktop/Myblogs/")); useShell(); &#125; static void genmulu()&#123; pb = new ProcessBuilder("/users/qiuzhibin/desktop/Myblogs/" + "genmulu.sh"); pb.directory(new File("/users/qiuzhibin/desktop/Myblogs/")); useShell(); &#125; //执行shell函数 public static String exec(String command) throws InterruptedException &#123; String returnString = ""; Process pro = null; Runtime runTime = Runtime.getRuntime(); if (runTime == null) &#123; System.err.println("Create runtime false!"); &#125; try &#123; pro = runTime.exec(command); BufferedReader input = new BufferedReader(new InputStreamReader(pro.getInputStream())); PrintWriter output = new PrintWriter(new OutputStreamWriter(pro.getOutputStream())); String line; while ((line = input.readLine()) != null) &#123; returnString = returnString + line + "\n"; &#125; input.close(); output.close(); pro.destroy(); &#125; catch (IOException ex) &#123; text.setText("没有该指令！"); &#125; return returnString; &#125; //使用shell文件 static void useShell()&#123; int runningStatus = 0; String s = null; try &#123; Process p = pb.start(); BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream())); BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream())); while ((s = stdInput.readLine()) != null) &#123; text.setText(s); &#125; while ((s = stdError.readLine()) != null) &#123; text.setText(s); &#125; try &#123; runningStatus = p.waitFor(); &#125; catch (InterruptedException e) &#123; text.setText("任务出错！"); &#125; &#125; catch (IOException e) &#123; &#125; if (runningStatus != 0) &#123; sss = sss+"\n"+"运行出错！"; text.setText(sss); &#125; else&#123; sss =sss+"\n"+"任务完成！"; text.setText(sss); &#125; return; &#125; //打开URL private static void browse(String url) throws Exception &#123; //获取操作系统的名字 String osName = System.getProperty("os.name", ""); if (osName.startsWith("Mac OS")) &#123; //苹果的打开方式 Class fileMgr = Class.forName("com.apple.eio.FileManager"); Method openURL = fileMgr.getDeclaredMethod("openURL", new Class[] &#123; String.class &#125;); openURL.invoke(null, new Object[] &#123; url &#125;); &#125; &#125; //监听类 static class Listener implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == bt1) &#123; sss = sss + "\n" + "正在打开文件...."; text.setText(sss); new Thread() &#123; public void run() &#123; seeWenjian(); sss = sss + "\n" + "成功打开文件...."; text.setText(sss); &#125; &#125;.start(); &#125; if (e.getSource() == ji1) &#123; new Thread() &#123; public void run() &#123; pb = new ProcessBuilder("/users/qiuzhibin/desktop/Myblogs/" + "port.sh"); pb.directory(new File("/users/qiuzhibin/desktop/Myblogs/")); useShell(); &#125; &#125;.start(); &#125; else if (e.getSource() == bt2) &#123; sss = sss + "\n" + "正在调试文件...."; text.setText(sss); new Thread() &#123; public void run() &#123; tiaoshi(); sss = sss + "\n" + "成功调试文件...."; text.setText(sss); &#125; &#125;.start(); &#125; else if (e.getSource() == bt3) &#123; sss = sss + "\n" + "正在更新....."; text.setText(sss); new Thread() &#123; public void run() &#123; updateblogs(); sss = sss + "\n" + "成功更新....."; text.setText(sss); &#125; &#125;.start(); &#125; else if (e.getSource() == bt4) &#123; sss = sss + "\n" + "正在打开....."; text.setText(sss); new Thread() &#123; public void run() &#123; try &#123; browse("https://qiuzhibin.com"); sss = sss + "\n" + "正在跳转....."; text.setText(sss); &#125; catch (Exception e) &#123; text.setText(sss + "\n" + e); &#125; &#125; &#125;.start(); &#125; else if (e.getSource() == bt5) &#123; sss = sss + "\n" + "正在打开....."; text.setText(sss); new Thread() &#123; public void run() &#123; try &#123; browse("http://localhost:4000/"); sss = sss + "\n" + "正在跳转....."; text.setText(sss); &#125; catch (Exception e) &#123; text.setText(sss + "\n" + e); &#125; &#125; &#125;.start(); &#125; else if (e.getSource() == bt6) &#123; sss = sss + "\n" + "正在打开....."; text.setText(sss); new Thread() &#123; public void run() &#123; text.setText("正在执行....."); try &#123; text.setText(exec(jtf.getText())); ; jtf.setText(""); &#125; catch (Exception e) &#123; text.setText("指令错误！"); &#125; &#125; &#125;.start(); &#125; else if (e.getSource() == bt7) &#123; sss = sss + "\n" + "正在打开文件...."; text.setText(sss); new Thread() &#123; public void run() &#123; genmulu(); &#125; &#125;.start(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>java swing</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
